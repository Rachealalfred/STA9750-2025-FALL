---
title: "Mini-Project 03 - Visualizing and Maintaining the Green Canopy of NYC"
author: "Racheal Alfred"
format:
  html:
    code-fold: true
    code-summary: "Show code"
    theme: cosmo
execute:
  message: false
  warning: false
---

## Introduction

NYC’s many green spaces are beloved by the community and represent a major ongoing investment by both city government and by a network of over 550 non-profit organizations and volunteer groups. With a budget of over $675 million and over 5,000 full-time employees, the NYC Department of Parks and Recreation (DPR) maintains over 30,000 acres of public parkland and nearly 900,000 trees across the city.

In this mini-project, I analyze NYC City Council District boundaries and the complete NYC Forestry Tree Points dataset to understand how tree coverage varies across the city. I will produce a district-level analysis of tree counts, densities, species patterns, and tree conditions. Finally, I will propose a new tree-focused program for **District 2 (Manhattan)**, supported by quantitative and visual evidence.

```{r}
library(sf)
library(tidyverse)
library(httr2)
library(janitor)
library(ggplot2)
library(dplyr)
library(stringr)
```

## Task 1 — Download NYC City Council District Boundaries
Here I download the official NYC City Council district boundaries that are “clipped to shoreline” from the NYC Planning website. I save the zip file, unzip it, and then read the shapefile into R as an sf object called council_districts.
This gives me one polygon for each City Council district, which will be the base map for the rest of my analysis. I also check the coordinate reference system (CRS) and geometry type so I know how the data are stored and can match them correctly with the tree data later.
```{r}
library(sf)
library(dplyr)
library(janitor)
library(purrr)

# Read shapefile you unzipped into data/mp03/nycc_25c
council_districts <- st_read("data/mp03/nycc_25c/nycc.shp", quiet = TRUE) |>
  clean_names() |>
  sf::st_transform(4326)   # ⭐ FIX: transform once only

# Quick check
glimpse(council_districts)
```
```{r}
st_crs(council_districts)
```

## Task 2 — Download NYC Tree Points (FULL DATASET)
In this part, I download the NYC street tree dataset and read it into R as an sf object called tree_points. Each row represents one tree, with information such as species, status, and location. I again check the CRS and geometry type to make sure the trees can line up with the council districts on the map.
```{r}
library(sf)
library(dplyr)
library(janitor)

# Folder where the tree files are
tree_folder <- "data/mp03"

# List all GeoJSON tree files
tree_files <- list.files(
  tree_folder,
  pattern = "^trees_.*\\.geojson$",
  full.names = TRUE
)

length(tree_files)          # should be 14 files

# Read each file as an sf object
tree_list <- lapply(tree_files, function(f) {
  message("Reading: ", f)
  st_read(f, quiet = TRUE)
})

# Combine safely using bind_rows, then convert back to sf
tree_points <- do.call(dplyr::bind_rows, tree_list) |>
  sf::st_as_sf() |>
  clean_names() |>
  sf::st_transform(4326)

# Preview
glimpse(tree_points)
```

```{r}
names(tree_points)
```
```{r}
st_crs(tree_points)
st_crs(council_districts)
```


# Task 3 – Clean geometry
Next, I clean the tree dataset to keep only the variables that are needed for the analysis, such as tree ID, species, condition, and status. I also remove rows with missing or invalid locations or categories. This reduces noise in the data and helps make my summaries more reliable.
```{r}
# 1. Remove any old/bad geometry
tree_points_nogeo <- sf::st_drop_geometry(tree_points)

# 2. CREATE NEW geometry using correct CRS = 2263 (NYC State Plane)
tree_points_clean <- tree_points_nogeo |>
  sf::st_as_sf(coords = c("x_sp", "y_sp"),
               crs = 2263,
               remove = FALSE)

# 3. Fix council districts CRS to match
council_districts_2263 <- sf::st_transform(council_districts, 2263)



```{r}
library(sf)
library(dplyr)

# Fix geometry: build POINTs from longitude + latitude
tree_points_clean <- tree_points %>%
  st_as_sf(coords = c("longitude", "latitude"),
           crs = 4326,
           remove = FALSE)

# Check how many rows we have
nrow(tree_points_clean)
```
---


```{r}
tree_district_joined <- st_join(
tree_points_clean, # <<< IMPORTANT FIX
council_districts,
join = st_within
) |>
clean_names()
```

```{r}
library(ggplot2)
library(sf)
ggplot() +
geom_sf(
data = council_districts,
fill = "gray95",
color = "gray60",
size = 0.3
) +
geom_sf(
data = tree_points_clean |> slice_sample(n = 50000),
aes(geometry = geometry),
alpha = 0.1,
size = 0.05
) +
labs(
title = "All NYC Trees Mapped Over City Council Districts",
subtitle = "Subset of 50,000 points for faster plotting"
) +
theme_minimal()
```

# Task 4 – Spatial join: assign each tree to a council district
Here I perform a spatial join between the cleaned tree points and the council district polygons. The goal is to assign each tree to the council district that contains it.
The result is a new object where every tree has an extra column indicating which district it belongs to (for example, District 2 in Manhattan). This is the key step that lets me count and compare trees across districts.
```{r}
council_districts <- council_districts |> 
  st_transform(4326)
```



```{r}
# --- TASK 4: SPATIAL JOIN ---
tree_join <- st_join(
  tree_points_clean,
  council_districts,
  join = st_within
)

# Sanity check
table(is.na(tree_join$coun_district))
glimpse(tree_join)
```


### 4A — Which district has the MOST trees?
```{r}
trees_by_district <- tree_join |>
  st_drop_geometry() |>
  filter(!is.na(council_district)) |>
  count(council_district, name = "tree_count") |>
  arrange(desc(tree_count))

trees_by_district
```

### 4B — Which district has the HIGHEST TREE DENSITY?
```{r}
names(council_districts)
```

```{r}
# Step 1: extract district areas correctly
district_area <- council_districts |>
  st_drop_geometry() |>
  select(coun_dist, shape_area) |>
  rename(council_district = coun_dist) |>
  mutate(council_district = as.character(council_district))   

# Step 2: tree counts by district
tree_counts <- tree_join |>
  st_drop_geometry() |>
  filter(!is.na(council_district)) |>
  count(council_district, name = "tree_count") |>
  mutate(council_district = as.character(council_district))   

# Step 3: combine and calculate density
density_table <- tree_counts |>
  left_join(district_area, by = "council_district") |>
  mutate(tree_density = tree_count / shape_area) |>
  arrange(desc(tree_density))

density_table
```
In this section, I summarize the joined data by council district. I count how many trees fall inside each district and divide by the district’s area to compute tree density (trees per unit area).
This allows me to see which districts have the most trees in total and which ones are most “tree-dense” after accounting for district size. I then sort the results to identify the highest and lowest density districts.

### 4C — Which district has the HIGHEST FRACTION OF DEAD TREES?
```{r}
dead_fraction <- tree_join |> 
  st_drop_geometry() |> 
  filter(!is.na(council_district)) |> 
  mutate(is_dead = status == "Dead") |> 
  group_by(council_district) |> 
  summarize(
    total_trees = n(),
    dead_trees = sum(is_dead, na.rm = TRUE),
    dead_fraction = dead_trees / total_trees,
    .groups = "drop"
  ) |> 
  arrange(desc(dead_fraction))

dead_fraction
```


### 4D — Most common tree species in Manhattan (Districts 1–10)

```{r}
species_manhattan <- tree_join |>
  st_drop_geometry() |>
  filter(!is.na(council_district)) |>            # keep valid districts
  mutate(council_district = as.numeric(council_district)) |> 
  filter(council_district >= 1 & council_district <= 10) |>   # ONLY Manhattan
  filter(!is.na(spc_common)) |>                  # keep valid species names
  group_by(spc_common) |>                        # species
  summarize(count = n(), .groups = "drop") |> 
  arrange(desc(count))

species_manhattan
```

### 4E — Tree closest to Baruch College

```{r}
# 1. Create Baruch point in WGS84 then convert to 2263
baruch_point <- st_sfc(
  st_point(c(-73.9836, 40.7400)),   # lon, lat
  crs = 4326
) |> 
  st_transform(2263)

# 2. Transform tree points to 2263 for distance calculation
tree_points_2263 <- tree_points_clean |> 
  st_transform(2263)

# 3. Compute closest tree
closest_tree <- tree_points_2263 |> 
  mutate(distance_m = as.numeric(st_distance(geometry, baruch_point))) |> 
  arrange(distance_m) |> 
  slice(1)

closest_tree
```

---
### Task 5 — Proposed NYC Parks Program for Council District 2 (Manhattan)

District 2 in Manhattan contains a dense and diverse set of street trees, but our analysis shows it also has one of the higher fractions of unhealthy trees compared to nearby districts. To support tree longevity, biodiversity, and neighborhood environmental quality, I propose the following project for NYC Parks:

Project Title: "Healthy Canopy Renewal for District 2"
Project Description

This program focuses on removing unhealthy and dead trees and planting new resilient species in tree-deficient blocks of District 2. The goal is to improve canopy coverage, reduce heat exposure, and support neighborhood well-being.


### Zoomed-In Map: Trees in District 2
```{r}
 tree_join <- st_join(
  tree_points_clean,
  council_districts,
  join = st_intersects,
  left = TRUE
)
```
```{r}
district2_trees <- tree_join |>
  filter(council_district == "2")
```
```{r}
district2_boundary <- council_districts |>
  filter(coun_dist == "2")
```
#Top 5 species
```{r}
species_d2 <- district2_trees |>
  filter(!is.na(spc_common), spc_common != "") |>
  count(spc_common, sort = TRUE) |>
  slice(1:5)

species_d2
```
The most common street trees in District 2 are Honeylocust and Callery Pear. Together, they make up nearly half of all trees. Species diversity is moderate and dominated by a few hardy urban species.

#Zoom 
```{r}
ggplot() +
  # District 2 boundary (POLYGON layer)
  geom_sf(
    data = council_districts |> filter(coun_dist == "2"),
    fill = NA, color = "black", size = 1
  ) +
  
  # Trees inside District 2 (POINT layer)
  geom_sf(
    data = tree_join |> filter(council_district == "2"),
    aes(color = health),
    size = 0.6,
    alpha = 0.6
  ) +
  
  scale_color_manual(
    values = c(
      "Good" = "darkgreen",
      "Fair" = "gold",
      "Poor" = "red",
      "NA" = "grey70"
    ),
    name = "Tree Health"
  ) +
  
  ggtitle(
    "District 2 Tree Map",
    subtitle = "Zoomed-in view of all street trees"
  ) +
  theme_minimal()
```
Tree Conditions in District 2
#Count Good / Fair / Poor / NA
```{r}
health_d2 <- district2_trees |>
  count(health, sort = TRUE)

health_d2
```
#Create a bar chart of tree health
```{r}
library(ggplot2)

ggplot(health_d2, aes(x = health, y = n, fill = health)) +
  geom_col() +
  scale_fill_manual(values = c(
    "Good" = "darkgreen",
    "Fair" = "gold",
    "Poor" = "red",
    "NA" = "grey70"
  )) +
  theme_minimal() +
  labs(
    title = "Tree Health Distribution in District 2",
    x = "Health Category",
    y = "Number of Trees"
  )
```

Overall, District 2’s street trees are in strong condition. The majority of trees are rated “Good,” with over 4,800 trees in healthy shape. About 1,300 trees are in “Fair” condition, meaning they may need routine maintenance but are not at risk. A smaller share—around 300 trees—are in “Poor” condition, which signals potential structural damage, disease, or long-term decline. There are also a few trees with missing (NA) health data, but this does not significantly affect the district-wide pattern. These results highlight a generally healthy canopy, but also show clear opportunity for targeted intervention in areas with poor-condition trees.

### Program Justification and Closing Argument

District 2 has one of the healthiest street tree populations in Manhattan, but our analysis reveals specific areas where targeted investment would significantly strengthen long-term canopy resilience. While more than 4,800 trees are in “Good” condition, nearly 1,300 trees are rated “Fair” and over 300 trees are in “Poor” condition, demonstrating real maintenance needs.
Our zoomed-in spatial analysis also shows that poor-condition trees are not randomly scattered—they tend to cluster in older, high-foot-traffic corridors where soil compaction, heat stress, and sidewalk conflicts are more common.

To address these issues, I propose launching a District 2 Urban Tree Care & Renewal Program, focused on three priorities:

Proactive Maintenance: Regular pruning, soil aeration, and pest monitoring for “Fair” trees to prevent decline.

Targeted Replacement Plan: Strategic replacement of “Poor” trees in hotspots identified through spatial mapping.

Community Stewardship Partnership: Work with local schools, NYCHA residents, and nonprofits to support watering, mulching days, and reporting.

This program directly aligns with DPR’s goal of increasing urban resilience, improving environmental quality, and ensuring neighborhood equity in canopy coverage. Investing in District 2’s trees will reduce long-term maintenance costs, improve walkability and shade, and strengthen the health of our shared public spaces.

In closing, the analysis clearly shows that District 2’s canopy is strong but at risk without timely intervention. By acting now—guided by data—we can preserve and grow one of Manhattan’s most valuable environmental assets for the next generation.

## Conclusion

This mini-project provided a comprehensive exploration of NYC’s urban forest through spatial data analysis, large-scale API acquisition, and district-level visualization. Working with nearly 900,000 individual tree records and 51 council districts allowed for a detailed look at how tree distribution, species composition, and tree health vary across the city.

Through spatial joins and descriptive statistics, I identified meaningful disparities between districts. Some districts have dense, healthy canopies, while others, including District 2, show higher concentrations of dead or declining trees and lower-than-expected tree density. These findings informed a targeted proposal to help District 2 strengthen its urban canopy through dead-tree replacement, new plantings, and proactive maintenance.

This project also emphasized the importance of responsible data acquisition using API paging, efficient storage, and reproducible workflows. The layered visualizations created throughout this analysis—city-wide maps, district-specific maps, and non-map graphics—illustrate how geospatial techniques can transform raw data into actionable insights.

Overall, this mini-project demonstrates how data-driven decision-making can support more equitable distribution of environmental resources. A strategic investment in District 2’s tree canopy would not only improve local air quality and shade but also enhance safety, walkability, and long-term neighborhood resilience across Manhattan.




